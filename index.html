<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Postcode Lookup</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    body { font-family: sans-serif; margin: 1em; }
    #map { width: 100%; height: 500px; margin-top: 1em; }
    label, select, input, button { margin: 0.25em; }
  </style>
</head>
<body>

  <h2>Postcode Lookup</h2>

  <label for="postcode">Enter postcode: </label>
  <input type="text" id="postcode" name="postcode" minlength="5" maxlength="8">
  <button type="button" id="searchBtn">Search</button>

  <div>
    <label for="streetSelect">Street:</label>
    <select id="streetSelect"></select>

    <label for="numberSelect">Number:</label>
    <select id="numberSelect"></select>
  </div>

  <div id="map"></div>

  <script>
    // --------------------------
    // Initialize Leaflet map
    // --------------------------
    const map = L.map('map').setView([52.517, 13.388], 9.5);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
    }).addTo(map);

    let circleLayer = null;

    // --------------------------
    // Robust district file fetch
    // --------------------------
    async function fetchDistrictFile(postcode) {
      if (!postcode) throw new Error("No postcode given");

      // Match 1â€“2 leading letters
      const districtMatch = postcode.trim().toUpperCase().match(/^[A-Z]{1,2}/);
      if (!districtMatch) throw new Error("Invalid postcode: " + postcode);
      const district = districtMatch[0];

      const relativePath = `districts_output/${encodeURIComponent(district)}.txt`;
      const url = new URL(relativePath, window.location.href).toString();
      console.log("Fetching:", url);

      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error(`Failed to fetch district file: ${resp.status} ${resp.statusText}`);
      }
      const text = await resp.text();
      return text.trim().split(/\r?\n/);
    }

    // --------------------------
    // Decode block header
    // --------------------------
    function decodeBlockHeader(headerLine) {
      // Example: =11288_-28=
      const m = headerLine.match(/^=(\-?\d+)_(-?\d+)=/);
      if (!m) return null;
      return [parseInt(m[1], 10), parseInt(m[2], 10)];
    }

    // --------------------------
    // Convert block coords to lat/lon
    // --------------------------
    function blockToLatLon(latBlock, lonBlock, blockSizeM=500) {
      const latBlockSize = blockSizeM / 111000;
      const lat = latBlock * latBlockSize;
      const lonBlockSize = blockSizeM / (111000 * Math.cos(lat * Math.PI/180));
      const lon = lonBlock * lonBlockSize;
      return [lat, lon];
    }

    // --------------------------
    // Main search handler
    // --------------------------
    document.getElementById("searchBtn").addEventListener("click", async () => {
      const postcode = document.getElementById("postcode").value.trim().toUpperCase();
      if (!postcode) return;

      try {
        const lines = await fetchDistrictFile(postcode);

        let currentBlock = null;
        const matches = [];

        for (const line of lines) {
          if (line.startsWith("=")) {
            currentBlock = decodeBlockHeader(line);
            continue;
          }
          const cols = line.split(",");
          const filePostcode = cols[0].trim().toUpperCase();
          if (filePostcode === postcode) {
            matches.push({
              block: currentBlock,
              postcode: filePostcode,
              street: cols[1],
              number: cols[2],
              subnumber: cols[3],
              memory: cols[4],
              prices: cols[5]?.split(";") || [],
              years: cols[6]?.split(";") || []
            });
          }
        }

        if (matches.length === 0) {
          alert("No matches found for " + postcode);
          return;
        }

        // Populate street select
        const streetSelect = document.getElementById("streetSelect");
        streetSelect.innerHTML = "";
        const streets = [...new Set(matches.map(m => m.street))];
        streets.forEach(st => {
          const opt = document.createElement("option");
          opt.value = st;
          opt.textContent = st;
          streetSelect.appendChild(opt);
        });

        // Populate numbers for first street
        updateNumberSelect(matches, streets[0]);

        streetSelect.addEventListener("change", () => {
          updateNumberSelect(matches, streetSelect.value);
        });

        // Show map circle for first match
        const first = matches[0];
        if (first.block) {
          const [lat, lon] = blockToLatLon(first.block[0], first.block[1]);
          if (circleLayer) map.removeLayer(circleLayer);
          circleLayer = L.circle([lat, lon], { radius: 600, color: "blue" }).addTo(map);
          map.setView([lat, lon], 15);
        }
      } catch (err) {
        console.error(err);
        alert(err.message);
      }
    });

    function updateNumberSelect(matches, street) {
      const numberSelect = document.getElementById("numberSelect");
      numberSelect.innerHTML = "";
      const nums = matches.filter(m => m.street === street).map(m => m.number);
      nums.forEach(n => {
        const opt = document.createElement("option");
        opt.value = n;
        opt.textContent = n;
        numberSelect.appendChild(opt);
      });
    }
  </script>
</body>
</html>
